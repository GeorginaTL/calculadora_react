{"ast":null,"code":"import { isConstantNode, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { safeNumberType } from '../../utils/number.js';\nvar name = 'derivative';\nvar dependencies = ['typed', 'config', 'parse', 'simplify', 'equal', 'isZero', 'numeric', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createDerivative = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    parse,\n    simplify,\n    equal,\n    isZero,\n    numeric,\n    ConstantNode,\n    FunctionNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  /**\n   * Takes the derivative of an expression expressed in parser Nodes.\n   * The derivative will be taken over the supplied variable in the\n   * second parameter. If there are multiple variables in the expression,\n   * it will return a partial derivative.\n   *\n   * This uses rules of differentiation which can be found here:\n   *\n   * - [Differentiation rules (Wikipedia)](https://en.wikipedia.org/wiki/Differentiation_rules)\n   *\n   * Syntax:\n   *\n   *     math.derivative(expr, variable)\n   *     math.derivative(expr, variable, options)\n   *\n   * Examples:\n   *\n   *     math.derivative('x^2', 'x')                     // Node '2 * x'\n   *     math.derivative('x^2', 'x', {simplify: false})  // Node '2 * 1 * x ^ (2 - 1)'\n   *     math.derivative('sin(2x)', 'x'))                // Node '2 * cos(2 * x)'\n   *     math.derivative('2*x', 'x').evaluate()          // number 2\n   *     math.derivative('x^2', 'x').evaluate({x: 4})    // number 8\n   *     const f = math.parse('x^2')\n   *     const x = math.parse('x')\n   *     math.derivative(f, x)                           // Node {2 * x}\n   *\n   * See also:\n   *\n   *     simplify, parse, evaluate\n   *\n   * @param  {Node | string} expr           The expression to differentiate\n   * @param  {SymbolNode | string} variable The variable over which to differentiate\n   * @param  {{simplify: boolean}} [options]\n   *                         There is one option available, `simplify`, which\n   *                         is true by default. When false, output will not\n   *                         be simplified.\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\n   */\n  function plainDerivative(expr, variable) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      simplify: true\n    };\n    var constNodes = {};\n    constTag(constNodes, expr, variable.name);\n    var res = _derivative(expr, constNodes);\n    return options.simplify ? simplify(res) : res;\n  }\n  function parseIdentifier(string) {\n    var symbol = parse(string);\n    if (!symbol.isSymbolNode) {\n      throw new TypeError('Invalid variable. ' + \"Cannot parse \".concat(JSON.stringify(string), \" into a variable in function derivative\"));\n    }\n    return symbol;\n  }\n  var derivative = typed(name, {\n    'Node, SymbolNode': plainDerivative,\n    'Node, SymbolNode, Object': plainDerivative,\n    'Node, string': (node, symbol) => plainDerivative(node, parseIdentifier(symbol)),\n    'Node, string, Object': (node, symbol, options) => plainDerivative(node, parseIdentifier(symbol), options)\n\n    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}\n    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {\n      let res = expr\n      for (let i = 0; i < order; i++) {\n        let constNodes = {}\n        constTag(constNodes, expr, variable.name)\n        res = _derivative(res, constNodes)\n      }\n      return res\n    }\n    */\n  });\n  derivative._simplify = true;\n  derivative.toTex = function (deriv) {\n    return _derivTex.apply(null, deriv.args);\n  };\n\n  // FIXME: move the toTex method of derivative to latex.js. Difficulty is that it relies on parse.\n  // NOTE: the optional \"order\" parameter here is currently unused\n  var _derivTex = typed('_derivTex', {\n    'Node, SymbolNode': function Node_SymbolNode(expr, x) {\n      if (isConstantNode(expr) && typeOf(expr.value) === 'string') {\n        return _derivTex(parse(expr.value).toString(), x.toString(), 1);\n      } else {\n        return _derivTex(expr.toTex(), x.toString(), 1);\n      }\n    },\n    'Node, ConstantNode': function Node_ConstantNode(expr, x) {\n      if (typeOf(x.value) === 'string') {\n        return _derivTex(expr, parse(x.value));\n      } else {\n        throw new Error(\"The second parameter to 'derivative' is a non-string constant\");\n      }\n    },\n    'Node, SymbolNode, ConstantNode': function Node_SymbolNode_ConstantNode(expr, x, order) {\n      return _derivTex(expr.toString(), x.name, order.value);\n    },\n    'string, string, number': function string_string_number(expr, x, order) {\n      var d;\n      if (order === 1) {\n        d = '{d\\\\over d' + x + '}';\n      } else {\n        d = '{d^{' + order + '}\\\\over d' + x + '^{' + order + '}}';\n      }\n      return d + \"\\\\left[\".concat(expr, \"\\\\right]\");\n    }\n  });\n\n  /**\n   * Does a depth-first search on the expression tree to identify what Nodes\n   * are constants (e.g. 2 + 2), and stores the ones that are constants in\n   * constNodes. Classification is done as follows:\n   *\n   *   1. ConstantNodes are constants.\n   *   2. If there exists a SymbolNode, of which we are differentiating over,\n   *      in the subtree it is not constant.\n   *\n   * @param  {Object} constNodes  Holds the nodes that are constant\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {string} varName     Variable that we are differentiating\n   * @return {boolean}  if node is constant\n   */\n  // TODO: can we rewrite constTag into a pure function?\n  var constTag = typed('constTag', {\n    'Object, ConstantNode, string': function Object_ConstantNode_string(constNodes, node) {\n      constNodes[node] = true;\n      return true;\n    },\n    'Object, SymbolNode, string': function Object_SymbolNode_string(constNodes, node, varName) {\n      // Treat other variables like constants. For reasoning, see:\n      //   https://en.wikipedia.org/wiki/Partial_derivative\n      if (node.name !== varName) {\n        constNodes[node] = true;\n        return true;\n      }\n      return false;\n    },\n    'Object, ParenthesisNode, string': function Object_ParenthesisNode_string(constNodes, node, varName) {\n      return constTag(constNodes, node.content, varName);\n    },\n    'Object, FunctionAssignmentNode, string': function Object_FunctionAssignmentNode_string(constNodes, node, varName) {\n      if (!node.params.includes(varName)) {\n        constNodes[node] = true;\n        return true;\n      }\n      return constTag(constNodes, node.expr, varName);\n    },\n    'Object, FunctionNode | OperatorNode, string': function Object_FunctionNode__OperatorNode_string(constNodes, node, varName) {\n      if (node.args.length > 0) {\n        var isConst = constTag(constNodes, node.args[0], varName);\n        for (var i = 1; i < node.args.length; ++i) {\n          isConst = constTag(constNodes, node.args[i], varName) && isConst;\n        }\n        if (isConst) {\n          constNodes[node] = true;\n          return true;\n        }\n      }\n      return false;\n    }\n  });\n\n  /**\n   * Applies differentiation rules.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {Object} constNodes  Holds the nodes that are constant\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\n   */\n  var _derivative = typed('_derivative', {\n    'ConstantNode, Object': function ConstantNode_Object(node) {\n      return createConstantNode(0);\n    },\n    'SymbolNode, Object': function SymbolNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      return createConstantNode(1);\n    },\n    'ParenthesisNode, Object': function ParenthesisNode_Object(node, constNodes) {\n      return new ParenthesisNode(_derivative(node.content, constNodes));\n    },\n    'FunctionAssignmentNode, Object': function FunctionAssignmentNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      return _derivative(node.expr, constNodes);\n    },\n    'FunctionNode, Object': function FunctionNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      var arg0 = node.args[0];\n      var arg1;\n      var div = false; // is output a fraction?\n      var negative = false; // is output negative?\n\n      var funcDerivative;\n      switch (node.name) {\n        case 'cbrt':\n          // d/dx(cbrt(x)) = 1 / (3x^(2/3))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(3), new OperatorNode('^', 'pow', [arg0, new OperatorNode('/', 'divide', [createConstantNode(2), createConstantNode(3)])])]);\n          break;\n        case 'sqrt':\n        case 'nthRoot':\n          // d/dx(sqrt(x)) = 1 / (2*sqrt(x))\n          if (node.args.length === 1) {\n            div = true;\n            funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(2), new FunctionNode('sqrt', [arg0])]);\n          } else if (node.args.length === 2) {\n            // Rearrange from nthRoot(x, a) -> x^(1/a)\n            arg1 = new OperatorNode('/', 'divide', [createConstantNode(1), node.args[1]]);\n\n            // Is a variable?\n            constNodes[arg1] = constNodes[node.args[1]];\n            return _derivative(new OperatorNode('^', 'pow', [arg0, arg1]), constNodes);\n          }\n          break;\n        case 'log10':\n          arg1 = createConstantNode(10);\n        /* fall through! */\n        case 'log':\n          if (!arg1 && node.args.length === 1) {\n            // d/dx(log(x)) = 1 / x\n            funcDerivative = arg0.clone();\n            div = true;\n          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {\n            // d/dx(log(x, c)) = 1 / (x*ln(c))\n            funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('log', [arg1 || node.args[1]])]);\n            div = true;\n          } else if (node.args.length === 2) {\n            // d/dx(log(f(x), g(x))) = d/dx(log(f(x)) / log(g(x)))\n            return _derivative(new OperatorNode('/', 'divide', [new FunctionNode('log', [arg0]), new FunctionNode('log', [node.args[1]])]), constNodes);\n          }\n          break;\n        case 'pow':\n          if (node.args.length === 2) {\n            constNodes[arg1] = constNodes[node.args[1]];\n            // Pass to pow operator node parser\n            return _derivative(new OperatorNode('^', 'pow', [arg0, node.args[1]]), constNodes);\n          }\n          break;\n        case 'exp':\n          // d/dx(e^x) = e^x\n          funcDerivative = new FunctionNode('exp', [arg0.clone()]);\n          break;\n        case 'sin':\n          // d/dx(sin(x)) = cos(x)\n          funcDerivative = new FunctionNode('cos', [arg0.clone()]);\n          break;\n        case 'cos':\n          // d/dx(cos(x)) = -sin(x)\n          funcDerivative = new OperatorNode('-', 'unaryMinus', [new FunctionNode('sin', [arg0.clone()])]);\n          break;\n        case 'tan':\n          // d/dx(tan(x)) = sec(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sec', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'sec':\n          // d/dx(sec(x)) = sec(x)tan(x)\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tan', [arg0.clone()])]);\n          break;\n        case 'csc':\n          // d/dx(csc(x)) = -csc(x)cot(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('cot', [arg0.clone()])]);\n          break;\n        case 'cot':\n          // d/dx(cot(x)) = -csc(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csc', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'asin':\n          // d/dx(asin(x)) = 1 / sqrt(1 - x^2)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n        case 'acos':\n          // d/dx(acos(x)) = -1 / sqrt(1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n        case 'atan':\n          // d/dx(atan(x)) = 1 / (x^2 + 1)\n          div = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n        case 'asec':\n          // d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n        case 'acsc':\n          // d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n        case 'acot':\n          // d/dx(acot(x)) = -1 / (x^2 + 1)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n        case 'sinh':\n          // d/dx(sinh(x)) = cosh(x)\n          funcDerivative = new FunctionNode('cosh', [arg0.clone()]);\n          break;\n        case 'cosh':\n          // d/dx(cosh(x)) = sinh(x)\n          funcDerivative = new FunctionNode('sinh', [arg0.clone()]);\n          break;\n        case 'tanh':\n          // d/dx(tanh(x)) = sech(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sech', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'sech':\n          // d/dx(sech(x)) = -sech(x)tanh(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tanh', [arg0.clone()])]);\n          break;\n        case 'csch':\n          // d/dx(csch(x)) = -csch(x)coth(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('coth', [arg0.clone()])]);\n          break;\n        case 'coth':\n          // d/dx(coth(x)) = -csch(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csch', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'asinh':\n          // d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n        case 'acosh':\n          // d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n        case 'atanh':\n          // d/dx(atanh(x)) = 1 / (1 - x^2)\n          div = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n        case 'asech':\n          // d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])])]);\n          break;\n        case 'acsch':\n          // d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n        case 'acoth':\n          // d/dx(acoth(x)) = -1 / (1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n        case 'abs':\n          // d/dx(abs(x)) = abs(x)/x\n          funcDerivative = new OperatorNode('/', 'divide', [new FunctionNode(new SymbolNode('abs'), [arg0.clone()]), arg0.clone()]);\n          break;\n        case 'gamma': // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)\n        default:\n          throw new Error('Cannot process function \"' + node.name + '\" in derivative: ' + 'the function is not supported, undefined, or the number of arguments passed to it are not supported');\n      }\n      var op, func;\n      if (div) {\n        op = '/';\n        func = 'divide';\n      } else {\n        op = '*';\n        func = 'multiply';\n      }\n\n      /* Apply chain rule to all functions:\n         F(x)  = f(g(x))\n         F'(x) = g'(x)*f'(g(x)) */\n      var chainDerivative = _derivative(arg0, constNodes);\n      if (negative) {\n        chainDerivative = new OperatorNode('-', 'unaryMinus', [chainDerivative]);\n      }\n      return new OperatorNode(op, func, [chainDerivative, funcDerivative]);\n    },\n    'OperatorNode, Object': function OperatorNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      if (node.op === '+') {\n        // d/dx(sum(f(x)) = sum(f'(x))\n        return new OperatorNode(node.op, node.fn, node.args.map(function (arg) {\n          return _derivative(arg, constNodes);\n        }));\n      }\n      if (node.op === '-') {\n        // d/dx(+/-f(x)) = +/-f'(x)\n        if (node.isUnary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);\n        }\n\n        // Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)\n        if (node.isBinary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);\n        }\n      }\n      if (node.op === '*') {\n        // d/dx(c*f(x)) = c*f'(x)\n        var constantTerms = node.args.filter(function (arg) {\n          return constNodes[arg] !== undefined;\n        });\n        if (constantTerms.length > 0) {\n          var nonConstantTerms = node.args.filter(function (arg) {\n            return constNodes[arg] === undefined;\n          });\n          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode('*', 'multiply', nonConstantTerms);\n          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));\n          return new OperatorNode('*', 'multiply', newArgs);\n        }\n\n        // Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)\n        return new OperatorNode('+', 'add', node.args.map(function (argOuter) {\n          return new OperatorNode('*', 'multiply', node.args.map(function (argInner) {\n            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();\n          }));\n        }));\n      }\n      if (node.op === '/' && node.isBinary()) {\n        var arg0 = node.args[0];\n        var arg1 = node.args[1];\n\n        // d/dx(f(x) / c) = f'(x) / c\n        if (constNodes[arg1] !== undefined) {\n          return new OperatorNode('/', 'divide', [_derivative(arg0, constNodes), arg1]);\n        }\n\n        // Reciprocal Rule, d/dx(c / f(x)) = -c(f'(x)/f(x)^2)\n        if (constNodes[arg0] !== undefined) {\n          return new OperatorNode('*', 'multiply', [new OperatorNode('-', 'unaryMinus', [arg0]), new OperatorNode('/', 'divide', [_derivative(arg1, constNodes), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])])]);\n        }\n\n        // Quotient rule, d/dx(f(x) / g(x)) = (f'(x)g(x) - f(x)g'(x)) / g(x)^2\n        return new OperatorNode('/', 'divide', [new OperatorNode('-', 'subtract', [new OperatorNode('*', 'multiply', [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode('*', 'multiply', [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])]);\n      }\n      if (node.op === '^' && node.isBinary()) {\n        var _arg = node.args[0];\n        var _arg2 = node.args[1];\n        if (constNodes[_arg] !== undefined) {\n          // If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1\n          if (isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {\n            return createConstantNode(0);\n          }\n\n          // d/dx(c^f(x)) = c^f(x)*ln(c)*f'(x)\n          return new OperatorNode('*', 'multiply', [node, new OperatorNode('*', 'multiply', [new FunctionNode('log', [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);\n        }\n        if (constNodes[_arg2] !== undefined) {\n          if (isConstantNode(_arg2)) {\n            // If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0\n            if (isZero(_arg2.value)) {\n              return createConstantNode(0);\n            }\n            // Ignore exponent; f(x)^1 = f(x)\n            if (equal(_arg2.value, 1)) {\n              return _derivative(_arg, constNodes);\n            }\n          }\n\n          // Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)\n          var powMinusOne = new OperatorNode('^', 'pow', [_arg.clone(), new OperatorNode('-', 'subtract', [_arg2, createConstantNode(1)])]);\n          return new OperatorNode('*', 'multiply', [_arg2.clone(), new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), powMinusOne])]);\n        }\n\n        // Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]\n        return new OperatorNode('*', 'multiply', [new OperatorNode('^', 'pow', [_arg.clone(), _arg2.clone()]), new OperatorNode('+', 'add', [new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), new OperatorNode('/', 'divide', [_arg2.clone(), _arg.clone()])]), new OperatorNode('*', 'multiply', [_derivative(_arg2, constNodes), new FunctionNode('log', [_arg.clone()])])])]);\n      }\n      throw new Error('Cannot process operator \"' + node.op + '\" in derivative: ' + 'the operator is not supported, undefined, or the number of arguments passed to it are not supported');\n    }\n  });\n\n  /**\n   * Helper function to create a constant node with a specific type\n   * (number, BigNumber, Fraction)\n   * @param {number} value\n   * @param {string} [valueType]\n   * @return {ConstantNode}\n   */\n  function createConstantNode(value, valueType) {\n    return new ConstantNode(numeric(value, valueType || safeNumberType(String(value), config)));\n  }\n  return derivative;\n});","map":{"version":3,"names":["isConstantNode","typeOf","factory","safeNumberType","name","dependencies","createDerivative","_ref","typed","config","parse","simplify","equal","isZero","numeric","ConstantNode","FunctionNode","OperatorNode","ParenthesisNode","SymbolNode","plainDerivative","expr","variable","options","arguments","length","undefined","constNodes","constTag","res","_derivative","parseIdentifier","string","symbol","isSymbolNode","TypeError","concat","JSON","stringify","derivative","Node, string","node","Node, string, Object","_simplify","toTex","deriv","_derivTex","apply","args","Node_SymbolNode","x","value","toString","Node_ConstantNode","Error","Node_SymbolNode_ConstantNode","order","string_string_number","d","Object_ConstantNode_string","Object_SymbolNode_string","varName","Object_ParenthesisNode_string","content","Object_FunctionAssignmentNode_string","params","includes","Object_FunctionNode__OperatorNode_string","isConst","i","ConstantNode_Object","createConstantNode","SymbolNode_Object","ParenthesisNode_Object","FunctionAssignmentNode_Object","FunctionNode_Object","arg0","arg1","div","negative","funcDerivative","clone","op","func","chainDerivative","OperatorNode_Object","fn","map","arg","isUnary","isBinary","constantTerms","filter","nonConstantTerms","nonConstantNode","newArgs","argOuter","argInner","_arg","_arg2","powMinusOne","valueType","String"],"sources":["D:/Georgina/1_Proyectos_React/node_modules/mathjs/lib/esm/function/algebra/derivative.js"],"sourcesContent":["import { isConstantNode, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { safeNumberType } from '../../utils/number.js';\nvar name = 'derivative';\nvar dependencies = ['typed', 'config', 'parse', 'simplify', 'equal', 'isZero', 'numeric', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createDerivative = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    parse,\n    simplify,\n    equal,\n    isZero,\n    numeric,\n    ConstantNode,\n    FunctionNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  /**\n   * Takes the derivative of an expression expressed in parser Nodes.\n   * The derivative will be taken over the supplied variable in the\n   * second parameter. If there are multiple variables in the expression,\n   * it will return a partial derivative.\n   *\n   * This uses rules of differentiation which can be found here:\n   *\n   * - [Differentiation rules (Wikipedia)](https://en.wikipedia.org/wiki/Differentiation_rules)\n   *\n   * Syntax:\n   *\n   *     math.derivative(expr, variable)\n   *     math.derivative(expr, variable, options)\n   *\n   * Examples:\n   *\n   *     math.derivative('x^2', 'x')                     // Node '2 * x'\n   *     math.derivative('x^2', 'x', {simplify: false})  // Node '2 * 1 * x ^ (2 - 1)'\n   *     math.derivative('sin(2x)', 'x'))                // Node '2 * cos(2 * x)'\n   *     math.derivative('2*x', 'x').evaluate()          // number 2\n   *     math.derivative('x^2', 'x').evaluate({x: 4})    // number 8\n   *     const f = math.parse('x^2')\n   *     const x = math.parse('x')\n   *     math.derivative(f, x)                           // Node {2 * x}\n   *\n   * See also:\n   *\n   *     simplify, parse, evaluate\n   *\n   * @param  {Node | string} expr           The expression to differentiate\n   * @param  {SymbolNode | string} variable The variable over which to differentiate\n   * @param  {{simplify: boolean}} [options]\n   *                         There is one option available, `simplify`, which\n   *                         is true by default. When false, output will not\n   *                         be simplified.\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\n   */\n  function plainDerivative(expr, variable) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      simplify: true\n    };\n    var constNodes = {};\n    constTag(constNodes, expr, variable.name);\n    var res = _derivative(expr, constNodes);\n    return options.simplify ? simplify(res) : res;\n  }\n  function parseIdentifier(string) {\n    var symbol = parse(string);\n    if (!symbol.isSymbolNode) {\n      throw new TypeError('Invalid variable. ' + \"Cannot parse \".concat(JSON.stringify(string), \" into a variable in function derivative\"));\n    }\n    return symbol;\n  }\n  var derivative = typed(name, {\n    'Node, SymbolNode': plainDerivative,\n    'Node, SymbolNode, Object': plainDerivative,\n    'Node, string': (node, symbol) => plainDerivative(node, parseIdentifier(symbol)),\n    'Node, string, Object': (node, symbol, options) => plainDerivative(node, parseIdentifier(symbol), options)\n\n    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}\n    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {\n      let res = expr\n      for (let i = 0; i < order; i++) {\n        let constNodes = {}\n        constTag(constNodes, expr, variable.name)\n        res = _derivative(res, constNodes)\n      }\n      return res\n    }\n    */\n  });\n  derivative._simplify = true;\n  derivative.toTex = function (deriv) {\n    return _derivTex.apply(null, deriv.args);\n  };\n\n  // FIXME: move the toTex method of derivative to latex.js. Difficulty is that it relies on parse.\n  // NOTE: the optional \"order\" parameter here is currently unused\n  var _derivTex = typed('_derivTex', {\n    'Node, SymbolNode': function Node_SymbolNode(expr, x) {\n      if (isConstantNode(expr) && typeOf(expr.value) === 'string') {\n        return _derivTex(parse(expr.value).toString(), x.toString(), 1);\n      } else {\n        return _derivTex(expr.toTex(), x.toString(), 1);\n      }\n    },\n    'Node, ConstantNode': function Node_ConstantNode(expr, x) {\n      if (typeOf(x.value) === 'string') {\n        return _derivTex(expr, parse(x.value));\n      } else {\n        throw new Error(\"The second parameter to 'derivative' is a non-string constant\");\n      }\n    },\n    'Node, SymbolNode, ConstantNode': function Node_SymbolNode_ConstantNode(expr, x, order) {\n      return _derivTex(expr.toString(), x.name, order.value);\n    },\n    'string, string, number': function string_string_number(expr, x, order) {\n      var d;\n      if (order === 1) {\n        d = '{d\\\\over d' + x + '}';\n      } else {\n        d = '{d^{' + order + '}\\\\over d' + x + '^{' + order + '}}';\n      }\n      return d + \"\\\\left[\".concat(expr, \"\\\\right]\");\n    }\n  });\n\n  /**\n   * Does a depth-first search on the expression tree to identify what Nodes\n   * are constants (e.g. 2 + 2), and stores the ones that are constants in\n   * constNodes. Classification is done as follows:\n   *\n   *   1. ConstantNodes are constants.\n   *   2. If there exists a SymbolNode, of which we are differentiating over,\n   *      in the subtree it is not constant.\n   *\n   * @param  {Object} constNodes  Holds the nodes that are constant\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {string} varName     Variable that we are differentiating\n   * @return {boolean}  if node is constant\n   */\n  // TODO: can we rewrite constTag into a pure function?\n  var constTag = typed('constTag', {\n    'Object, ConstantNode, string': function Object_ConstantNode_string(constNodes, node) {\n      constNodes[node] = true;\n      return true;\n    },\n    'Object, SymbolNode, string': function Object_SymbolNode_string(constNodes, node, varName) {\n      // Treat other variables like constants. For reasoning, see:\n      //   https://en.wikipedia.org/wiki/Partial_derivative\n      if (node.name !== varName) {\n        constNodes[node] = true;\n        return true;\n      }\n      return false;\n    },\n    'Object, ParenthesisNode, string': function Object_ParenthesisNode_string(constNodes, node, varName) {\n      return constTag(constNodes, node.content, varName);\n    },\n    'Object, FunctionAssignmentNode, string': function Object_FunctionAssignmentNode_string(constNodes, node, varName) {\n      if (!node.params.includes(varName)) {\n        constNodes[node] = true;\n        return true;\n      }\n      return constTag(constNodes, node.expr, varName);\n    },\n    'Object, FunctionNode | OperatorNode, string': function Object_FunctionNode__OperatorNode_string(constNodes, node, varName) {\n      if (node.args.length > 0) {\n        var isConst = constTag(constNodes, node.args[0], varName);\n        for (var i = 1; i < node.args.length; ++i) {\n          isConst = constTag(constNodes, node.args[i], varName) && isConst;\n        }\n        if (isConst) {\n          constNodes[node] = true;\n          return true;\n        }\n      }\n      return false;\n    }\n  });\n\n  /**\n   * Applies differentiation rules.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {Object} constNodes  Holds the nodes that are constant\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\n   */\n  var _derivative = typed('_derivative', {\n    'ConstantNode, Object': function ConstantNode_Object(node) {\n      return createConstantNode(0);\n    },\n    'SymbolNode, Object': function SymbolNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      return createConstantNode(1);\n    },\n    'ParenthesisNode, Object': function ParenthesisNode_Object(node, constNodes) {\n      return new ParenthesisNode(_derivative(node.content, constNodes));\n    },\n    'FunctionAssignmentNode, Object': function FunctionAssignmentNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      return _derivative(node.expr, constNodes);\n    },\n    'FunctionNode, Object': function FunctionNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      var arg0 = node.args[0];\n      var arg1;\n      var div = false; // is output a fraction?\n      var negative = false; // is output negative?\n\n      var funcDerivative;\n      switch (node.name) {\n        case 'cbrt':\n          // d/dx(cbrt(x)) = 1 / (3x^(2/3))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(3), new OperatorNode('^', 'pow', [arg0, new OperatorNode('/', 'divide', [createConstantNode(2), createConstantNode(3)])])]);\n          break;\n        case 'sqrt':\n        case 'nthRoot':\n          // d/dx(sqrt(x)) = 1 / (2*sqrt(x))\n          if (node.args.length === 1) {\n            div = true;\n            funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(2), new FunctionNode('sqrt', [arg0])]);\n          } else if (node.args.length === 2) {\n            // Rearrange from nthRoot(x, a) -> x^(1/a)\n            arg1 = new OperatorNode('/', 'divide', [createConstantNode(1), node.args[1]]);\n\n            // Is a variable?\n            constNodes[arg1] = constNodes[node.args[1]];\n            return _derivative(new OperatorNode('^', 'pow', [arg0, arg1]), constNodes);\n          }\n          break;\n        case 'log10':\n          arg1 = createConstantNode(10);\n        /* fall through! */\n        case 'log':\n          if (!arg1 && node.args.length === 1) {\n            // d/dx(log(x)) = 1 / x\n            funcDerivative = arg0.clone();\n            div = true;\n          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {\n            // d/dx(log(x, c)) = 1 / (x*ln(c))\n            funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('log', [arg1 || node.args[1]])]);\n            div = true;\n          } else if (node.args.length === 2) {\n            // d/dx(log(f(x), g(x))) = d/dx(log(f(x)) / log(g(x)))\n            return _derivative(new OperatorNode('/', 'divide', [new FunctionNode('log', [arg0]), new FunctionNode('log', [node.args[1]])]), constNodes);\n          }\n          break;\n        case 'pow':\n          if (node.args.length === 2) {\n            constNodes[arg1] = constNodes[node.args[1]];\n            // Pass to pow operator node parser\n            return _derivative(new OperatorNode('^', 'pow', [arg0, node.args[1]]), constNodes);\n          }\n          break;\n        case 'exp':\n          // d/dx(e^x) = e^x\n          funcDerivative = new FunctionNode('exp', [arg0.clone()]);\n          break;\n        case 'sin':\n          // d/dx(sin(x)) = cos(x)\n          funcDerivative = new FunctionNode('cos', [arg0.clone()]);\n          break;\n        case 'cos':\n          // d/dx(cos(x)) = -sin(x)\n          funcDerivative = new OperatorNode('-', 'unaryMinus', [new FunctionNode('sin', [arg0.clone()])]);\n          break;\n        case 'tan':\n          // d/dx(tan(x)) = sec(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sec', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'sec':\n          // d/dx(sec(x)) = sec(x)tan(x)\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tan', [arg0.clone()])]);\n          break;\n        case 'csc':\n          // d/dx(csc(x)) = -csc(x)cot(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('cot', [arg0.clone()])]);\n          break;\n        case 'cot':\n          // d/dx(cot(x)) = -csc(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csc', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'asin':\n          // d/dx(asin(x)) = 1 / sqrt(1 - x^2)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n        case 'acos':\n          // d/dx(acos(x)) = -1 / sqrt(1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n        case 'atan':\n          // d/dx(atan(x)) = 1 / (x^2 + 1)\n          div = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n        case 'asec':\n          // d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n        case 'acsc':\n          // d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n        case 'acot':\n          // d/dx(acot(x)) = -1 / (x^2 + 1)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n        case 'sinh':\n          // d/dx(sinh(x)) = cosh(x)\n          funcDerivative = new FunctionNode('cosh', [arg0.clone()]);\n          break;\n        case 'cosh':\n          // d/dx(cosh(x)) = sinh(x)\n          funcDerivative = new FunctionNode('sinh', [arg0.clone()]);\n          break;\n        case 'tanh':\n          // d/dx(tanh(x)) = sech(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sech', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'sech':\n          // d/dx(sech(x)) = -sech(x)tanh(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tanh', [arg0.clone()])]);\n          break;\n        case 'csch':\n          // d/dx(csch(x)) = -csch(x)coth(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('coth', [arg0.clone()])]);\n          break;\n        case 'coth':\n          // d/dx(coth(x)) = -csch(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csch', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'asinh':\n          // d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n        case 'acosh':\n          // d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n        case 'atanh':\n          // d/dx(atanh(x)) = 1 / (1 - x^2)\n          div = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n        case 'asech':\n          // d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])])]);\n          break;\n        case 'acsch':\n          // d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n        case 'acoth':\n          // d/dx(acoth(x)) = -1 / (1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n        case 'abs':\n          // d/dx(abs(x)) = abs(x)/x\n          funcDerivative = new OperatorNode('/', 'divide', [new FunctionNode(new SymbolNode('abs'), [arg0.clone()]), arg0.clone()]);\n          break;\n        case 'gamma': // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)\n        default:\n          throw new Error('Cannot process function \"' + node.name + '\" in derivative: ' + 'the function is not supported, undefined, or the number of arguments passed to it are not supported');\n      }\n      var op, func;\n      if (div) {\n        op = '/';\n        func = 'divide';\n      } else {\n        op = '*';\n        func = 'multiply';\n      }\n\n      /* Apply chain rule to all functions:\n         F(x)  = f(g(x))\n         F'(x) = g'(x)*f'(g(x)) */\n      var chainDerivative = _derivative(arg0, constNodes);\n      if (negative) {\n        chainDerivative = new OperatorNode('-', 'unaryMinus', [chainDerivative]);\n      }\n      return new OperatorNode(op, func, [chainDerivative, funcDerivative]);\n    },\n    'OperatorNode, Object': function OperatorNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      if (node.op === '+') {\n        // d/dx(sum(f(x)) = sum(f'(x))\n        return new OperatorNode(node.op, node.fn, node.args.map(function (arg) {\n          return _derivative(arg, constNodes);\n        }));\n      }\n      if (node.op === '-') {\n        // d/dx(+/-f(x)) = +/-f'(x)\n        if (node.isUnary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);\n        }\n\n        // Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)\n        if (node.isBinary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);\n        }\n      }\n      if (node.op === '*') {\n        // d/dx(c*f(x)) = c*f'(x)\n        var constantTerms = node.args.filter(function (arg) {\n          return constNodes[arg] !== undefined;\n        });\n        if (constantTerms.length > 0) {\n          var nonConstantTerms = node.args.filter(function (arg) {\n            return constNodes[arg] === undefined;\n          });\n          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode('*', 'multiply', nonConstantTerms);\n          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));\n          return new OperatorNode('*', 'multiply', newArgs);\n        }\n\n        // Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)\n        return new OperatorNode('+', 'add', node.args.map(function (argOuter) {\n          return new OperatorNode('*', 'multiply', node.args.map(function (argInner) {\n            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();\n          }));\n        }));\n      }\n      if (node.op === '/' && node.isBinary()) {\n        var arg0 = node.args[0];\n        var arg1 = node.args[1];\n\n        // d/dx(f(x) / c) = f'(x) / c\n        if (constNodes[arg1] !== undefined) {\n          return new OperatorNode('/', 'divide', [_derivative(arg0, constNodes), arg1]);\n        }\n\n        // Reciprocal Rule, d/dx(c / f(x)) = -c(f'(x)/f(x)^2)\n        if (constNodes[arg0] !== undefined) {\n          return new OperatorNode('*', 'multiply', [new OperatorNode('-', 'unaryMinus', [arg0]), new OperatorNode('/', 'divide', [_derivative(arg1, constNodes), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])])]);\n        }\n\n        // Quotient rule, d/dx(f(x) / g(x)) = (f'(x)g(x) - f(x)g'(x)) / g(x)^2\n        return new OperatorNode('/', 'divide', [new OperatorNode('-', 'subtract', [new OperatorNode('*', 'multiply', [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode('*', 'multiply', [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])]);\n      }\n      if (node.op === '^' && node.isBinary()) {\n        var _arg = node.args[0];\n        var _arg2 = node.args[1];\n        if (constNodes[_arg] !== undefined) {\n          // If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1\n          if (isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {\n            return createConstantNode(0);\n          }\n\n          // d/dx(c^f(x)) = c^f(x)*ln(c)*f'(x)\n          return new OperatorNode('*', 'multiply', [node, new OperatorNode('*', 'multiply', [new FunctionNode('log', [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);\n        }\n        if (constNodes[_arg2] !== undefined) {\n          if (isConstantNode(_arg2)) {\n            // If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0\n            if (isZero(_arg2.value)) {\n              return createConstantNode(0);\n            }\n            // Ignore exponent; f(x)^1 = f(x)\n            if (equal(_arg2.value, 1)) {\n              return _derivative(_arg, constNodes);\n            }\n          }\n\n          // Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)\n          var powMinusOne = new OperatorNode('^', 'pow', [_arg.clone(), new OperatorNode('-', 'subtract', [_arg2, createConstantNode(1)])]);\n          return new OperatorNode('*', 'multiply', [_arg2.clone(), new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), powMinusOne])]);\n        }\n\n        // Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]\n        return new OperatorNode('*', 'multiply', [new OperatorNode('^', 'pow', [_arg.clone(), _arg2.clone()]), new OperatorNode('+', 'add', [new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), new OperatorNode('/', 'divide', [_arg2.clone(), _arg.clone()])]), new OperatorNode('*', 'multiply', [_derivative(_arg2, constNodes), new FunctionNode('log', [_arg.clone()])])])]);\n      }\n      throw new Error('Cannot process operator \"' + node.op + '\" in derivative: ' + 'the operator is not supported, undefined, or the number of arguments passed to it are not supported');\n    }\n  });\n\n  /**\n   * Helper function to create a constant node with a specific type\n   * (number, BigNumber, Fraction)\n   * @param {number} value\n   * @param {string} [valueType]\n   * @return {ConstantNode}\n   */\n  function createConstantNode(value, valueType) {\n    return new ConstantNode(numeric(value, valueType || safeNumberType(String(value), config)));\n  }\n  return derivative;\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}